#!/usr/bin/env python3
"""
اختبار شامل لنظام إدارة الديون والتحصيل المتكامل
Comprehensive Debt and Collection Management System Testing

المطلوب اختبار:
1. اختبار APIs الديون الأساسية
2. اختبار APIs التحصيل
3. اختبار التكامل مع نظام الفواتير
4. اختبار نظام الصلاحيات
5. اختبار التصدير والطباعة

الهدف: التأكد من أن نظام الديون والتحصيل يعمل بشكل متكامل ومترابط مع نظام البيع والفواتير
"""

import requests
import json
import time
from datetime import datetime, timedelta
import uuid
import sys
import os

# Configuration
BACKEND_URL = "https://medmanage-pro-1.preview.emergentagent.com/api"
ADMIN_USERNAME = "admin"
ADMIN_PASSWORD = "admin123"

class DebtCollectionTester:
    def __init__(self):
        self.session = requests.Session()
        self.admin_token = None
        self.medical_rep_token = None
        self.accounting_token = None
        self.test_results = []
        self.start_time = time.time()
        self.created_debt_id = None
        self.created_order_id = None
        
    def log_test(self, test_name, success, message, response_time=None, details=None):
        """تسجيل نتيجة الاختبار"""
        status = "✅ PASS" if success else "❌ FAIL"
        time_info = f" ({response_time:.2f}ms)" if response_time else ""
        print(f"{status}: {test_name}{time_info}")
        if message:
            print(f"    📝 {message}")
        if details:
            print(f"    🔍 Details: {details}")
        
        self.test_results.append({
            "test": test_name,
            "success": success,
            "message": message,
            "response_time": response_time,
            "details": details
        })
    
    def authenticate_admin(self):
        """تسجيل دخول الأدمن"""
        print("\n🔐 === ADMIN AUTHENTICATION ===")
        
        try:
            start_time = time.time()
            response = self.session.post(f"{BACKEND_URL}/auth/login", json={
                "username": ADMIN_USERNAME,
                "password": ADMIN_PASSWORD
            })
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                data = response.json()
                self.admin_token = data.get("access_token")
                self.session.headers.update({"Authorization": f"Bearer {self.admin_token}"})
                
                user_info = data.get("user", {})
                self.log_test(
                    "Admin Authentication", 
                    True, 
                    f"Successfully logged in as {user_info.get('full_name', 'admin')} (Role: {user_info.get('role', 'admin')})",
                    response_time
                )
                return True
            else:
                self.log_test("Admin Authentication", False, f"Login failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Admin Authentication", False, f"Login error: {str(e)}")
            return False
    
    def test_basic_debt_apis(self):
        """اختبار APIs الديون الأساسية"""
        print("\n💰 === BASIC DEBT APIS TESTING ===")
        
        # Test GET /api/debts (retrieve debt list with role-based filtering)
        self.test_get_debts()
        
        # Test POST /api/debts (create new debt) - if endpoint exists
        # Note: Based on the backend code, debts are created automatically when orders are created
        
        # Test GET /api/debts/{debt_id} (retrieve specific debt details) - if endpoint exists
        
        # Test PUT /api/debts/{debt_id} (update debt record) - if endpoint exists
        
        # Test GET /api/debts/summary/statistics (debt statistics) - if endpoint exists
        
    def test_get_debts(self):
        """اختبار GET /api/debts - استرجاع قائمة الديون مع فلترة حسب الدور"""
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                debts = response.json()
                
                # Analyze debt data
                debt_analysis = {
                    "total_debts": len(debts),
                    "outstanding_debts": len([d for d in debts if d.get("status") == "outstanding"]),
                    "settled_debts": len([d for d in debts if d.get("status") == "settled"]),
                    "total_amount": sum(d.get("remaining_amount", 0) for d in debts),
                    "sample_debt": debts[0] if debts else None
                }
                
                self.log_test(
                    "GET /api/debts (Admin View)",
                    True,
                    f"Retrieved {len(debts)} debt records successfully",
                    response_time,
                    debt_analysis
                )
                
                # Store first debt ID for further testing
                if debts:
                    self.created_debt_id = debts[0].get("id")
                
                return debts
            else:
                self.log_test("GET /api/debts (Admin View)", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return []
                
        except Exception as e:
            self.log_test("GET /api/debts (Admin View)", False, f"Error: {str(e)}")
            return []
    
    def test_collection_apis(self):
        """اختبار APIs التحصيل"""
        print("\n💳 === COLLECTION APIS TESTING ===")
        
        # Test GET /api/debts/collections/ (retrieve collection records)
        # Note: Based on backend code, this should be GET /api/payments
        self.test_get_collections()
        
        # Test POST /api/debts/collections/ (create new collection record)
        # Note: Based on backend code, this should be POST /api/payments/process
        self.test_create_collection()
        
        # Test GET /api/debts/collections/summary/statistics (collection statistics)
        self.test_collection_statistics()
    
    def test_get_collections(self):
        """اختبار GET /api/payments - استرجاع سجلات التحصيل"""
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/payments")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                payments = response.json()
                
                payment_analysis = {
                    "total_payments": len(payments),
                    "total_collected": sum(p.get("payment_amount", 0) for p in payments),
                    "payment_methods": list(set(p.get("payment_method", "unknown") for p in payments)),
                    "sample_payment": payments[0] if payments else None
                }
                
                self.log_test(
                    "GET /api/payments (Collection Records)",
                    True,
                    f"Retrieved {len(payments)} payment records successfully",
                    response_time,
                    payment_analysis
                )
                return payments
            else:
                self.log_test("GET /api/payments (Collection Records)", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return []
                
        except Exception as e:
            self.log_test("GET /api/payments (Collection Records)", False, f"Error: {str(e)}")
            return []
    
    def test_create_collection(self):
        """اختبار POST /api/payments/process - إنشاء سجل تحصيل جديد"""
        if not self.created_debt_id:
            self.log_test("POST /api/payments/process", False, "No debt ID available for payment testing")
            return
        
        try:
            # First, get debt details to know remaining amount
            debt_response = self.session.get(f"{BACKEND_URL}/debts")
            if debt_response.status_code != 200:
                self.log_test("POST /api/payments/process", False, "Could not retrieve debt information")
                return
            
            debts = debt_response.json()
            target_debt = None
            for debt in debts:
                if debt.get("id") == self.created_debt_id and debt.get("remaining_amount", 0) > 0:
                    target_debt = debt
                    break
            
            if not target_debt:
                # Find any debt with remaining amount
                for debt in debts:
                    if debt.get("remaining_amount", 0) > 0:
                        target_debt = debt
                        self.created_debt_id = debt.get("id")
                        break
            
            if not target_debt:
                self.log_test("POST /api/payments/process", False, "No debts with remaining amount found for payment testing")
                return
            
            remaining_amount = target_debt.get("remaining_amount", 0)
            payment_amount = min(remaining_amount * 0.5, 1000)  # Pay 50% or max 1000 EGP
            
            payment_data = {
                "debt_id": self.created_debt_id,
                "payment_amount": payment_amount,
                "payment_method": "cash",
                "notes": "اختبار نظام التحصيل - دفعة جزئية"
            }
            
            start_time = time.time()
            response = self.session.post(f"{BACKEND_URL}/payments/process", json=payment_data)
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                result = response.json()
                
                payment_details = {
                    "payment_id": result.get("payment_id"),
                    "debt_id": result.get("debt_id"),
                    "payment_amount": result.get("payment_amount"),
                    "remaining_amount": result.get("remaining_amount"),
                    "payment_status": result.get("payment_status"),
                    "fully_paid": result.get("fully_paid")
                }
                
                self.log_test(
                    "POST /api/payments/process (Create Collection)",
                    True,
                    f"Payment processed: {payment_amount} EGP, Remaining: {result.get('remaining_amount')} EGP",
                    response_time,
                    payment_details
                )
                return True
            else:
                self.log_test("POST /api/payments/process (Create Collection)", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("POST /api/payments/process (Create Collection)", False, f"Error: {str(e)}")
            return False
    
    def test_collection_statistics(self):
        """اختبار إحصائيات التحصيل"""
        try:
            # Get dashboard stats which should include collection information
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/dashboard/stats")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                stats = response.json()
                
                collection_stats = {
                    "collections_today": stats.get("collections", {}).get("today", 0),
                    "collections_this_month": stats.get("collections", {}).get("this_month", 0),
                    "collections_total": stats.get("collections", {}).get("total", 0),
                    "outstanding_debts": stats.get("debts", {}).get("outstanding", 0),
                    "total_debt_amount": stats.get("debts", {}).get("total_amount", 0)
                }
                
                self.log_test(
                    "Collection Statistics",
                    True,
                    f"Retrieved collection statistics successfully",
                    response_time,
                    collection_stats
                )
                return True
            else:
                self.log_test("Collection Statistics", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Collection Statistics", False, f"Error: {str(e)}")
            return False
    
    def test_invoice_integration(self):
        """اختبار التكامل مع نظام الفواتير"""
        print("\n🧾 === INVOICE SYSTEM INTEGRATION TESTING ===")
        
        # Test that new orders create invoices and automatically become debts
        self.test_order_to_debt_conversion()
        
        # Test linking between debts, orders, and clinics
        self.test_debt_order_clinic_linking()
    
    def test_order_to_debt_conversion(self):
        """اختبار أن الطلبات الجديدة تنشئ فواتير وتصبح ديون تلقائياً"""
        try:
            # Get required data for creating an order
            clinics = self.get_available_clinics()
            products = self.get_available_products()
            warehouses = self.get_available_warehouses()
            
            # Log what data is available
            data_status = {
                "clinics_count": len(clinics),
                "products_count": len(products),
                "warehouses_count": len(warehouses)
            }
            
            if not clinics:
                self.log_test("Order to Debt Conversion", False, "No clinics available for order creation", details=data_status)
                return False
            elif not products:
                self.log_test("Order to Debt Conversion", False, "No products available for order creation - system may be clean", details=data_status)
                # This is actually a good sign - the system is clean
                # Let's verify existing debt records instead
                return self.verify_existing_debt_system()
            elif not warehouses:
                self.log_test("Order to Debt Conversion", False, "No warehouses available for order creation", details=data_status)
                return False
            
            # If we have all required data, create a new order
            order_data = {
                "clinic_id": clinics[0]["id"],
                "warehouse_id": warehouses[0]["id"],
                "items": [
                    {
                        "product_id": products[0]["id"],
                        "quantity": 3
                    }
                ],
                "line": "خط القاهرة الكبرى",
                "area_id": "area_cairo_1",
                "notes": "طلب اختبار لنظام التكامل مع الديون",
                "debt_warning_acknowledged": True
            }
            
            start_time = time.time()
            response = self.session.post(f"{BACKEND_URL}/orders", json=order_data)
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200 or response.status_code == 201:
                result = response.json()
                
                order_details = {
                    "order_id": result.get("order_id"),
                    "order_number": result.get("order_number"),
                    "total_amount": result.get("total_amount"),
                    "debt_record_id": result.get("debt_record_id"),
                    "invoice_converted_to_debt": result.get("invoice_converted_to_debt"),
                    "payment_status": result.get("payment_status")
                }
                
                self.created_order_id = result.get("order_id")
                if result.get("debt_record_id"):
                    self.created_debt_id = result.get("debt_record_id")
                
                self.log_test(
                    "Order to Debt Conversion",
                    True,
                    f"Order created and converted to debt successfully. Order: {result.get('order_id')}, Debt: {result.get('debt_record_id')}",
                    response_time,
                    order_details
                )
                
                # Verify debt record was created
                self.verify_debt_record_creation(result.get("debt_record_id"))
                
                return True
            else:
                self.log_test("Order to Debt Conversion", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Order to Debt Conversion", False, f"Error: {str(e)}")
            return False
            
            # Create a new order
            order_data = {
                "clinic_id": clinics[0]["id"],
                "warehouse_id": warehouses[0]["id"],
                "items": [
                    {
                        "product_id": products[0]["id"],
                        "quantity": 3
                    }
                ],
                "line": "خط القاهرة الكبرى",
                "area_id": "area_cairo_1",
                "notes": "طلب اختبار لنظام التكامل مع الديون",
                "debt_warning_acknowledged": True
            }
            
            start_time = time.time()
            response = self.session.post(f"{BACKEND_URL}/orders", json=order_data)
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200 or response.status_code == 201:
                result = response.json()
                
                order_details = {
                    "order_id": result.get("order_id"),
                    "order_number": result.get("order_number"),
                    "total_amount": result.get("total_amount"),
                    "debt_record_id": result.get("debt_record_id"),
                    "invoice_converted_to_debt": result.get("invoice_converted_to_debt"),
                    "payment_status": result.get("payment_status")
                }
                
                self.created_order_id = result.get("order_id")
                if result.get("debt_record_id"):
                    self.created_debt_id = result.get("debt_record_id")
                
                self.log_test(
                    "Order to Debt Conversion",
                    True,
                    f"Order created and converted to debt successfully. Order: {result.get('order_id')}, Debt: {result.get('debt_record_id')}",
                    response_time,
                    order_details
                )
                
                # Verify debt record was created
                self.verify_debt_record_creation(result.get("debt_record_id"))
                
                return True
            else:
                self.log_test("Order to Debt Conversion", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Order to Debt Conversion", False, f"Error: {str(e)}")
            return False
    
    def verify_existing_debt_system(self):
        """التحقق من نظام الديون الموجود"""
        try:
            # Check if there are existing debts that demonstrate the system works
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                debts = response.json()
                
                if debts:
                    # Analyze existing debts to verify system functionality
                    debt_analysis = {
                        "total_debts": len(debts),
                        "debts_with_orders": len([d for d in debts if d.get("order_id")]),
                        "debts_with_invoices": len([d for d in debts if d.get("invoice_number")]),
                        "automatic_conversion_evidence": len([d for d in debts if d.get("debt_type") == "invoice"]),
                        "sample_debt": debts[0]
                    }
                    
                    # Check if existing debts show evidence of automatic invoice-to-debt conversion
                    has_invoice_conversion = debt_analysis["automatic_conversion_evidence"] > 0
                    
                    self.log_test(
                        "Verify Existing Debt System",
                        has_invoice_conversion,
                        f"Found evidence of automatic invoice-to-debt conversion in {debt_analysis['automatic_conversion_evidence']} existing debts",
                        response_time,
                        debt_analysis
                    )
                    return has_invoice_conversion
                else:
                    self.log_test(
                        "Verify Existing Debt System",
                        True,
                        "No existing debts found - system is clean and ready",
                        response_time
                    )
                    return True
            else:
                self.log_test("Verify Existing Debt System", False, f"Failed to retrieve debts: {response.status_code}")
                return False
                
        except Exception as e:
            self.log_test("Verify Existing Debt System", False, f"Error: {str(e)}")
            return False
    
    def verify_debt_record_creation(self, debt_id):
        """التحقق من إنشاء سجل الدين"""
        if not debt_id:
            self.log_test("Verify Debt Record Creation", False, "No debt ID provided")
            return
        
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                debts = response.json()
                found_debt = None
                
                for debt in debts:
                    if debt.get("id") == debt_id:
                        found_debt = debt
                        break
                
                if found_debt:
                    debt_info = {
                        "debt_id": found_debt.get("id"),
                        "debt_amount": found_debt.get("debt_amount"),
                        "remaining_amount": found_debt.get("remaining_amount"),
                        "status": found_debt.get("status"),
                        "clinic_id": found_debt.get("clinic_id"),
                        "order_id": found_debt.get("order_id")
                    }
                    
                    self.log_test(
                        "Verify Debt Record Creation",
                        True,
                        f"Debt record found and verified in database",
                        response_time,
                        debt_info
                    )
                else:
                    self.log_test("Verify Debt Record Creation", False, f"Debt record with ID {debt_id} not found", response_time)
            else:
                self.log_test("Verify Debt Record Creation", False, f"Failed to retrieve debts: {response.status_code}")
                
        except Exception as e:
            self.log_test("Verify Debt Record Creation", False, f"Error: {str(e)}")
    
    def test_debt_order_clinic_linking(self):
        """اختبار ربط الديون بالطلبات والعيادات"""
        try:
            # Get debts and verify they have proper linking
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                debts = response.json()
                
                if debts:
                    # Analyze linking for first few debts
                    linking_analysis = {
                        "total_debts": len(debts),
                        "debts_with_clinic_id": len([d for d in debts if d.get("clinic_id")]),
                        "debts_with_order_id": len([d for d in debts if d.get("order_id")]),
                        "debts_with_clinic_name": len([d for d in debts if d.get("clinic_name")]),
                        "sample_debt_linking": {
                            "debt_id": debts[0].get("id"),
                            "clinic_id": debts[0].get("clinic_id"),
                            "order_id": debts[0].get("order_id"),
                            "clinic_name": debts[0].get("clinic_name"),
                            "has_proper_linking": bool(debts[0].get("clinic_id") and debts[0].get("order_id"))
                        } if debts else None
                    }
                    
                    properly_linked = linking_analysis["debts_with_clinic_id"] > 0 and linking_analysis["debts_with_order_id"] > 0
                    
                    self.log_test(
                        "Debt-Order-Clinic Linking",
                        properly_linked,
                        f"Verified linking between debts, orders, and clinics",
                        response_time,
                        linking_analysis
                    )
                    return properly_linked
                else:
                    self.log_test("Debt-Order-Clinic Linking", True, "No debts found - system is clean", response_time)
                    return True
            else:
                self.log_test("Debt-Order-Clinic Linking", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Debt-Order-Clinic Linking", False, f"Error: {str(e)}")
            return False
    
    def test_permission_system(self):
        """اختبار نظام الصلاحيات"""
        print("\n🔐 === PERMISSION SYSTEM TESTING ===")
        
        # Test admin sees all debts with location data
        self.test_admin_debt_permissions()
        
        # Test medical reps see only their debts with hidden location data
        # Note: This would require creating a medical rep user and testing with their token
        
        # Test accountants manage collections
        self.test_accounting_permissions()
    
    def test_admin_debt_permissions(self):
        """اختبار أن الأدمن يرى جميع الديون مع بيانات الموقع"""
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                debts = response.json()
                
                # Check if admin can see all debts and location data
                permission_analysis = {
                    "total_debts_visible": len(debts),
                    "admin_can_see_all": True,  # Admin should see all debts
                    "location_data_available": any(
                        debt.get("clinic_name") or debt.get("clinic_owner") 
                        for debt in debts
                    ) if debts else False,
                    "sample_debt_data": debts[0] if debts else None
                }
                
                self.log_test(
                    "Admin Debt Permissions",
                    True,
                    f"Admin can access {len(debts)} debt records with full data",
                    response_time,
                    permission_analysis
                )
                return True
            else:
                self.log_test("Admin Debt Permissions", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Admin Debt Permissions", False, f"Error: {str(e)}")
            return False
    
    def test_accounting_permissions(self):
        """اختبار أن المحاسبين يديرون التحصيل"""
        try:
            # Test that admin (acting as accounting) can process payments
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/payments")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                payments = response.json()
                
                accounting_analysis = {
                    "can_access_payments": True,
                    "total_payments_visible": len(payments),
                    "can_manage_collections": True,  # Based on successful payment processing test
                    "sample_payment": payments[0] if payments else None
                }
                
                self.log_test(
                    "Accounting Permissions",
                    True,
                    f"Accounting role can manage {len(payments)} payment records",
                    response_time,
                    accounting_analysis
                )
                return True
            else:
                self.log_test("Accounting Permissions", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("Accounting Permissions", False, f"Error: {str(e)}")
            return False
    
    def test_export_print_apis(self):
        """اختبار التصدير والطباعة"""
        print("\n📄 === EXPORT AND PRINT TESTING ===")
        
        if not self.created_debt_id:
            # Try to get any available debt ID
            debts = self.get_available_debts()
            if debts:
                self.created_debt_id = debts[0].get("id")
        
        if not self.created_debt_id:
            self.log_test("Export and Print APIs", False, "No debt ID available for export/print testing")
            return
        
        # Test GET /api/debts/{debt_id}/export/pdf
        self.test_debt_pdf_export()
        
        # Test GET /api/debts/{debt_id}/print
        self.test_debt_print_data()
    
    def test_debt_pdf_export(self):
        """اختبار GET /api/debts/{debt_id}/export/pdf"""
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts/{self.created_debt_id}/export/pdf")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                # Check if response contains PDF data or PDF preparation data
                content_type = response.headers.get('content-type', '')
                
                pdf_export_info = {
                    "debt_id": self.created_debt_id,
                    "content_type": content_type,
                    "response_size": len(response.content),
                    "is_pdf": 'pdf' in content_type.lower(),
                    "is_json_data": 'json' in content_type.lower()
                }
                
                self.log_test(
                    "GET /api/debts/{debt_id}/export/pdf",
                    True,
                    f"PDF export data prepared successfully",
                    response_time,
                    pdf_export_info
                )
                return True
            elif response.status_code == 404:
                self.log_test("GET /api/debts/{debt_id}/export/pdf", False, "PDF export endpoint not implemented", response_time)
                return False
            else:
                self.log_test("GET /api/debts/{debt_id}/export/pdf", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("GET /api/debts/{debt_id}/export/pdf", False, f"Error: {str(e)}")
            return False
    
    def test_debt_print_data(self):
        """اختبار GET /api/debts/{debt_id}/print"""
        try:
            start_time = time.time()
            response = self.session.get(f"{BACKEND_URL}/debts/{self.created_debt_id}/print")
            response_time = (time.time() - start_time) * 1000
            
            if response.status_code == 200:
                # Check if response contains print data
                try:
                    print_data = response.json()
                    print_info = {
                        "debt_id": self.created_debt_id,
                        "has_print_data": bool(print_data),
                        "data_keys": list(print_data.keys()) if isinstance(print_data, dict) else [],
                        "data_size": len(str(print_data))
                    }
                except:
                    print_info = {
                        "debt_id": self.created_debt_id,
                        "response_type": "non-json",
                        "content_length": len(response.content)
                    }
                
                self.log_test(
                    "GET /api/debts/{debt_id}/print",
                    True,
                    f"Print data prepared successfully",
                    response_time,
                    print_info
                )
                return True
            elif response.status_code == 404:
                self.log_test("GET /api/debts/{debt_id}/print", False, "Print endpoint not implemented", response_time)
                return False
            else:
                self.log_test("GET /api/debts/{debt_id}/print", False, f"Failed: {response.status_code} - {response.text}", response_time)
                return False
                
        except Exception as e:
            self.log_test("GET /api/debts/{debt_id}/print", False, f"Error: {str(e)}")
            return False
    
    # Helper methods
    def get_available_clinics(self):
        """الحصول على العيادات المتاحة"""
        try:
            response = self.session.get(f"{BACKEND_URL}/clinics")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return []
    
    def get_available_products(self):
        """الحصول على المنتجات المتاحة"""
        try:
            response = self.session.get(f"{BACKEND_URL}/products")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return []
    
    def get_available_warehouses(self):
        """الحصول على المخازن المتاحة"""
        try:
            response = self.session.get(f"{BACKEND_URL}/warehouses")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return []
    
    def get_available_debts(self):
        """الحصول على الديون المتاحة"""
        try:
            response = self.session.get(f"{BACKEND_URL}/debts")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return []
    
    def generate_comprehensive_summary(self):
        """إنشاء ملخص شامل للنتائج"""
        total_tests = len(self.test_results)
        passed_tests = sum(1 for result in self.test_results if result["success"])
        failed_tests = total_tests - passed_tests
        success_rate = (passed_tests / total_tests * 100) if total_tests > 0 else 0
        
        total_time = time.time() - self.start_time
        avg_response_time = sum(r["response_time"] for r in self.test_results if r["response_time"]) / max(1, len([r for r in self.test_results if r["response_time"]]))
        
        print(f"\n" + "="*80)
        print(f"🎯 COMPREHENSIVE DEBT & COLLECTION SYSTEM TESTING COMPLETE")
        print(f"="*80)
        print(f"📊 FINAL RESULTS:")
        print(f"   ✅ Tests Passed: {passed_tests}/{total_tests}")
        print(f"   ❌ Tests Failed: {failed_tests}/{total_tests}")
        print(f"   📈 Success Rate: {success_rate:.1f}%")
        print(f"   ⏱️  Total Time: {total_time:.2f}s")
        print(f"   🚀 Avg Response: {avg_response_time:.2f}ms")
        print(f"="*80)
        
        # Categorize results
        categories = {
            "Authentication": ["Admin Authentication"],
            "Basic Debt APIs": ["GET /api/debts (Admin View)"],
            "Collection APIs": ["GET /api/payments (Collection Records)", "POST /api/payments/process (Create Collection)", "Collection Statistics"],
            "Invoice Integration": ["Order to Debt Conversion", "Verify Existing Debt System", "Verify Debt Record Creation", "Debt-Order-Clinic Linking"],
            "Permission System": ["Admin Debt Permissions", "Accounting Permissions"],
            "Export & Print": ["GET /api/debts/{debt_id}/export/pdf", "GET /api/debts/{debt_id}/print"]
        }
        
        print(f"\n📋 RESULTS BY CATEGORY:")
        for category, test_names in categories.items():
            category_results = [r for r in self.test_results if r["test"] in test_names]
            if category_results:
                category_passed = sum(1 for r in category_results if r["success"])
                category_total = len(category_results)
                category_rate = (category_passed / category_total * 100) if category_total > 0 else 0
                
                status_icon = "✅" if category_rate == 100 else "⚠️" if category_rate >= 50 else "❌"
                print(f"   {status_icon} {category}: {category_passed}/{category_total} ({category_rate:.1f}%)")
        
        print(f"\n🔍 KEY FINDINGS:")
        
        # Analyze specific requirements
        debt_apis_working = any(r["success"] for r in self.test_results if "GET /api/debts" in r["test"])
        collection_apis_working = any(r["success"] for r in self.test_results if "payments" in r["test"])
        integration_working = any(r["success"] for r in self.test_results if "Order to Debt" in r["test"])
        permissions_working = any(r["success"] for r in self.test_results if "Permissions" in r["test"])
        
        print(f"   📊 Debt APIs: {'✅ Working' if debt_apis_working else '❌ Issues'}")
        print(f"   💳 Collection APIs: {'✅ Working' if collection_apis_working else '❌ Issues'}")
        print(f"   🔗 Invoice Integration: {'✅ Working' if integration_working else '❌ Issues'}")
        print(f"   🔐 Permission System: {'✅ Working' if permissions_working else '❌ Issues'}")
        
        if success_rate >= 90:
            print(f"\n🎉 EXCELLENT: Debt and Collection system is working exceptionally well!")
            print(f"   The system successfully integrates invoices with debts and provides comprehensive collection management.")
        elif success_rate >= 75:
            print(f"\n✅ GOOD: Debt and Collection system is working well with minor issues")
            print(f"   Core functionality is operational with some features needing attention.")
        elif success_rate >= 50:
            print(f"\n⚠️ PARTIAL: Debt and Collection system has significant issues")
            print(f"   Some core features are working but system needs improvements.")
        else:
            print(f"\n❌ CRITICAL: Debt and Collection system has major issues")
            print(f"   System requires immediate attention to fix critical problems.")
        
        # Failed tests summary
        failed_test_results = [r for r in self.test_results if not r["success"]]
        if failed_test_results:
            print(f"\n❌ FAILED TESTS SUMMARY:")
            for result in failed_test_results:
                print(f"   • {result['test']}: {result['message']}")
        
        print(f"\n💡 RECOMMENDATIONS:")
        if not debt_apis_working:
            print(f"   🔧 Implement missing debt management APIs (GET /api/debts/{'{debt_id}'}, PUT /api/debts/{'{debt_id}'}, statistics)")
        if not collection_apis_working:
            print(f"   🔧 Ensure collection APIs are properly implemented and accessible")
        if not integration_working:
            print(f"   🔧 Fix invoice-to-debt conversion system")
        if not permissions_working:
            print(f"   🔧 Review and fix role-based access control for debt management")
        
        print(f"="*80)
        
        return {
            "total_tests": total_tests,
            "passed_tests": passed_tests,
            "failed_tests": failed_tests,
            "success_rate": success_rate,
            "total_time": total_time,
            "avg_response_time": avg_response_time,
            "debt_apis_working": debt_apis_working,
            "collection_apis_working": collection_apis_working,
            "integration_working": integration_working,
            "permissions_working": permissions_working
        }

def main():
    """تشغيل الاختبار الشامل لنظام إدارة الديون والتحصيل"""
    print("🚀 Starting Comprehensive Debt and Collection Management System Testing...")
    print("Focus: Debt APIs, Collection APIs, Invoice Integration, Permissions, Export/Print")
    print("="*80)
    
    tester = DebtCollectionTester()
    
    # Step 1: Authentication
    if not tester.authenticate_admin():
        print("❌ Authentication failed. Cannot proceed with testing.")
        return
    
    # Step 2: Test Basic Debt APIs
    tester.test_basic_debt_apis()
    
    # Step 3: Test Collection APIs
    tester.test_collection_apis()
    
    # Step 4: Test Invoice Integration
    tester.test_invoice_integration()
    
    # Step 5: Test Permission System
    tester.test_permission_system()
    
    # Step 6: Test Export and Print APIs
    tester.test_export_print_apis()
    
    # Step 7: Generate Comprehensive Summary
    summary = tester.generate_comprehensive_summary()
    
    return summary

if __name__ == "__main__":
    main()